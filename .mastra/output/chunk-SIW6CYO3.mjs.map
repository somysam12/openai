{"version":3,"file":"chunk-SIW6CYO3.mjs","sources":["../../node_modules/@mastra/server/dist/chunk-SIW6CYO3.js"],"sourcesContent":["import { require_token_error } from './chunk-FZNS32WJ.js';\nimport { __commonJS, __require } from './chunk-PR4QN5HX.js';\n\n// ../../node_modules/.pnpm/@vercel+oidc@3.0.1/node_modules/@vercel/oidc/dist/token-io.js\nvar require_token_io = __commonJS({\n  \"../../node_modules/.pnpm/@vercel+oidc@3.0.1/node_modules/@vercel/oidc/dist/token-io.js\"(exports, module) {\n    var __create = Object.create;\n    var __defProp = Object.defineProperty;\n    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames = Object.getOwnPropertyNames;\n    var __getProtoOf = Object.getPrototypeOf;\n    var __hasOwnProp = Object.prototype.hasOwnProperty;\n    var __export = (target, all) => {\n      for (var name in all)\n        __defProp(target, name, { get: all[name], enumerable: true });\n    };\n    var __copyProps = (to, from, except, desc) => {\n      if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))\n          if (!__hasOwnProp.call(to, key) && key !== except)\n            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n      }\n      return to;\n    };\n    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n      // If the importer is in node compatibility mode or this is not an ESM\n      // file that has been converted to a CommonJS file using a Babel-\n      // compatible transform (i.e. \"__esModule\" has not been set), then set\n      // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n      !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n      mod\n    ));\n    var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n    var token_io_exports = {};\n    __export(token_io_exports, {\n      findRootDir: () => findRootDir,\n      getUserDataDir: () => getUserDataDir\n    });\n    module.exports = __toCommonJS(token_io_exports);\n    var import_path = __toESM(__require(\"path\"));\n    var import_fs = __toESM(__require(\"fs\"));\n    var import_os = __toESM(__require(\"os\"));\n    var import_token_error = require_token_error();\n    function findRootDir() {\n      try {\n        let dir = process.cwd();\n        while (dir !== import_path.default.dirname(dir)) {\n          const pkgPath = import_path.default.join(dir, \".vercel\");\n          if (import_fs.default.existsSync(pkgPath)) {\n            return dir;\n          }\n          dir = import_path.default.dirname(dir);\n        }\n      } catch (e) {\n        throw new import_token_error.VercelOidcTokenError(\n          \"Token refresh only supported in node server environments\"\n        );\n      }\n      throw new import_token_error.VercelOidcTokenError(\"Unable to find root directory\");\n    }\n    function getUserDataDir() {\n      if (process.env.XDG_DATA_HOME) {\n        return process.env.XDG_DATA_HOME;\n      }\n      switch (import_os.default.platform()) {\n        case \"darwin\":\n          return import_path.default.join(import_os.default.homedir(), \"Library/Application Support\");\n        case \"linux\":\n          return import_path.default.join(import_os.default.homedir(), \".local/share\");\n        case \"win32\":\n          if (process.env.LOCALAPPDATA) {\n            return process.env.LOCALAPPDATA;\n          }\n          return null;\n        default:\n          return null;\n      }\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/@vercel+oidc@3.0.1/node_modules/@vercel/oidc/dist/token-util.js\nvar require_token_util = __commonJS({\n  \"../../node_modules/.pnpm/@vercel+oidc@3.0.1/node_modules/@vercel/oidc/dist/token-util.js\"(exports, module) {\n    var __create = Object.create;\n    var __defProp = Object.defineProperty;\n    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames = Object.getOwnPropertyNames;\n    var __getProtoOf = Object.getPrototypeOf;\n    var __hasOwnProp = Object.prototype.hasOwnProperty;\n    var __export = (target, all) => {\n      for (var name in all)\n        __defProp(target, name, { get: all[name], enumerable: true });\n    };\n    var __copyProps = (to, from, except, desc) => {\n      if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))\n          if (!__hasOwnProp.call(to, key) && key !== except)\n            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n      }\n      return to;\n    };\n    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n      // If the importer is in node compatibility mode or this is not an ESM\n      // file that has been converted to a CommonJS file using a Babel-\n      // compatible transform (i.e. \"__esModule\" has not been set), then set\n      // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n      !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n      mod\n    ));\n    var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n    var token_util_exports = {};\n    __export(token_util_exports, {\n      assertVercelOidcTokenResponse: () => assertVercelOidcTokenResponse,\n      findProjectInfo: () => findProjectInfo,\n      getTokenPayload: () => getTokenPayload,\n      getVercelCliToken: () => getVercelCliToken,\n      getVercelDataDir: () => getVercelDataDir,\n      getVercelOidcToken: () => getVercelOidcToken,\n      isExpired: () => isExpired,\n      loadToken: () => loadToken,\n      saveToken: () => saveToken\n    });\n    module.exports = __toCommonJS(token_util_exports);\n    var path = __toESM(__require(\"path\"));\n    var fs = __toESM(__require(\"fs\"));\n    var import_token_error = require_token_error();\n    var import_token_io = require_token_io();\n    function getVercelDataDir() {\n      const vercelFolder = \"com.vercel.cli\";\n      const dataDir = (0, import_token_io.getUserDataDir)();\n      if (!dataDir) {\n        return null;\n      }\n      return path.join(dataDir, vercelFolder);\n    }\n    function getVercelCliToken() {\n      const dataDir = getVercelDataDir();\n      if (!dataDir) {\n        return null;\n      }\n      const tokenPath = path.join(dataDir, \"auth.json\");\n      if (!fs.existsSync(tokenPath)) {\n        return null;\n      }\n      const token = fs.readFileSync(tokenPath, \"utf8\");\n      if (!token) {\n        return null;\n      }\n      return JSON.parse(token).token;\n    }\n    async function getVercelOidcToken(authToken, projectId, teamId) {\n      try {\n        const url = `https://api.vercel.com/v1/projects/${projectId}/token?source=vercel-oidc-refresh${teamId ? `&teamId=${teamId}` : \"\"}`;\n        const res = await fetch(url, {\n          method: \"POST\",\n          headers: {\n            Authorization: `Bearer ${authToken}`\n          }\n        });\n        if (!res.ok) {\n          throw new import_token_error.VercelOidcTokenError(\n            `Failed to refresh OIDC token: ${res.statusText}`\n          );\n        }\n        const tokenRes = await res.json();\n        assertVercelOidcTokenResponse(tokenRes);\n        return tokenRes;\n      } catch (e) {\n        throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, e);\n      }\n    }\n    function assertVercelOidcTokenResponse(res) {\n      if (!res || typeof res !== \"object\") {\n        throw new TypeError(\"Expected an object\");\n      }\n      if (!(\"token\" in res) || typeof res.token !== \"string\") {\n        throw new TypeError(\"Expected a string-valued token property\");\n      }\n    }\n    function findProjectInfo() {\n      const dir = (0, import_token_io.findRootDir)();\n      if (!dir) {\n        throw new import_token_error.VercelOidcTokenError(\"Unable to find root directory\");\n      }\n      try {\n        const prjPath = path.join(dir, \".vercel\", \"project.json\");\n        if (!fs.existsSync(prjPath)) {\n          throw new import_token_error.VercelOidcTokenError(\"project.json not found\");\n        }\n        const prj = JSON.parse(fs.readFileSync(prjPath, \"utf8\"));\n        if (typeof prj.projectId !== \"string\" && typeof prj.orgId !== \"string\") {\n          throw new TypeError(\"Expected a string-valued projectId property\");\n        }\n        return { projectId: prj.projectId, teamId: prj.orgId };\n      } catch (e) {\n        throw new import_token_error.VercelOidcTokenError(`Unable to find project ID`, e);\n      }\n    }\n    function saveToken(token, projectId) {\n      try {\n        const dir = (0, import_token_io.getUserDataDir)();\n        if (!dir) {\n          throw new import_token_error.VercelOidcTokenError(\"Unable to find user data directory\");\n        }\n        const tokenPath = path.join(dir, \"com.vercel.token\", `${projectId}.json`);\n        const tokenJson = JSON.stringify(token);\n        fs.mkdirSync(path.dirname(tokenPath), { mode: 432, recursive: true });\n        fs.writeFileSync(tokenPath, tokenJson);\n        fs.chmodSync(tokenPath, 432);\n        return;\n      } catch (e) {\n        throw new import_token_error.VercelOidcTokenError(`Failed to save token`, e);\n      }\n    }\n    function loadToken(projectId) {\n      try {\n        const dir = (0, import_token_io.getUserDataDir)();\n        if (!dir) {\n          return null;\n        }\n        const tokenPath = path.join(dir, \"com.vercel.token\", `${projectId}.json`);\n        if (!fs.existsSync(tokenPath)) {\n          return null;\n        }\n        const token = JSON.parse(fs.readFileSync(tokenPath, \"utf8\"));\n        assertVercelOidcTokenResponse(token);\n        return token;\n      } catch (e) {\n        throw new import_token_error.VercelOidcTokenError(`Failed to load token`, e);\n      }\n    }\n    function getTokenPayload(token) {\n      const tokenParts = token.split(\".\");\n      if (tokenParts.length !== 3) {\n        throw new import_token_error.VercelOidcTokenError(\"Invalid token\");\n      }\n      const base64 = tokenParts[1].replace(/-/g, \"+\").replace(/_/g, \"/\");\n      const padded = base64.padEnd(\n        base64.length + (4 - base64.length % 4) % 4,\n        \"=\"\n      );\n      return JSON.parse(Buffer.from(padded, \"base64\").toString(\"utf8\"));\n    }\n    var TIME_15_MINUTES_IN_MS = 15 * 60 * 1e3;\n    function isExpired(token) {\n      return token.exp * 1e3 < Date.now() + TIME_15_MINUTES_IN_MS;\n    }\n  }\n});\n\nexport { require_token_util };\n//# sourceMappingURL=chunk-SIW6CYO3.js.map\n//# sourceMappingURL=chunk-SIW6CYO3.js.map"],"names":[],"mappings":";;;;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;","x_google_ignoreList":[0]}